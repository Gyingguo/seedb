\section{SeeDB Backend}
\label{subsec:seedb_backend}

The \SeeDB\ backend is responsible for all the computations for 
generating and selecting views. 
%\agp{next line can be deleted if needing space, repetitive.}
 As shown in Figure~\ref{fig:sys-arch}, the \SeeDB\ backend is composed of four
 modules that are respectively responsible for collecting metadata (Metadata Collector), pruning
 the view space and generating view queries (Query Generator), optimizing view
 queries (Optimizer), and processing query results to identify the top-$k$
 interesting views (View Processor). 
To achieve its goal of finding the most
interesting views accurately and efficiently, the \SeeDB\ backend must not only accurately
estimate the accuracy of a large number of views but also design ways in which
the total processing time will be minimized.
We first describe the basic \SeeDB\ backend framework and then briefly discuss our optimizations.

% One of the chief challenges in \SeeDB\ is producing the most interesting views
% of the query result in the least possible time. For achieve the above
% performance goal, \SeeDB\ must perform optimizations at two stages: first, using
% prior knowledge such as statistics to prune out uninteresting views without examining table data; and second, minimizing the
% execution time for queries that are issued to the database. 

\subsection{Basic Framework}
\label{subsubsec:basic_framework}

Given a user query $Q$, the basic approach computes all
possible two-column views obtained by adding a single-attribute aggregate and group-by clause to $Q$. 
The target and comparison views corresponding to each view are then
computed and each view query is executed independently on the DBMS. The query
results for each view are normalized, and utility is computed as the
distance between these two distributions (Section \ref{sec:problem_statement}).
Finally, the top-$k$ views with the largest utility are chosen to be displayed. 
The basic approach is clearly inefficient
since it examines every possible view 
and executes each view query independently.
We next discuss how our optimizations fix these problems.

\subsection{View Space Pruning}
\label{subsubsec:view_space_pruning}

In practice, most views for any query $Q$ have low utility since the target view
distribution is very similar to the comparison view distribution. 
\SeeDB\ uses this property to aggressively prune 
view queries that are unlikely to have high utility. 
This pruning is based on metadata about the table including data
distributions and access patterns. 
Specifically, no expensive scans of the underlying
tables are performed. In addition, we order the execution of view queries so
that higher utility views can be computed before those with lower utility,
thus permitting early stopping. For each table in the DBMS, we assume that
statistics from Table~\ref{tab:statistics} are available or can be computed
cheaply. The data type for each column is numeric, categorical, ordinal, geographic, or
date\_or\_time. The data type for column $C_i$, $T(C_i)$, along with the number
of distinct values $|C_i|$ is used to determine whether the column will be
treated as a {\it dimension} attribute or a {\it measure}
attribute (Section~\ref{subsec:definitions}). As before, we denote the set of
dimension attributes by $\mathcal{D}$ and measure by $\mathcal{M}$.

We employ the following heuristics for pruning and ordering views based on the
statistics above.

\begin{table}
{\scriptsize \center
\vspace{-10pt}
\begin{tabular}{|c|c|c|c|}
\hline
$T(C_i)$ & Data type for column $C_i$ \\ \hline
$|C_i|$ & Number of distinct values in $C_i$ \\
\hline $Var(C_i)$ & Variance of values in $C_i$ \\ \hline
$Corr(C_i, C_j)$ & Correlation measure for all pairs of columns \\ \hline
$\mathcal{H}_{i\ldots k}$ & Hierarchies between columns $C_i$ to $C_k$ \\ \hline
$f_{C_i}, f_{C_i, C_j}$ & Frequency of access for each column and column pair \\
\hline
\end{tabular} 
\vspace{-10pt}
\caption{Statistics and Table Metadata \label{tab:statistics}}
}
\end{table}

\vspace{5 mm}

\squishlist
\item {\bf  Variance-based pruning}: Dimension attributes with low variance are
likely to produce views having low utility (e.g. consider the extreme case where
an attribute only takes a single value); \SeeDB\ therefore prunes views
with grouping attributes with low variance.
\item {\bf  Correlated attributes}: If two dimension attributes $a_i$ and $a_j$ have
a high degree of correlation (e.g. full name of airport and abbreviated name of
airport), the views generated by grouping the table on $a_i$ and $a_j$ will be
very similar (and have almost equal utility). We can therefore generate and
evaluate a single view representing both $a_i$ and $a_j$. \SeeDB\ clusters
attributes based on correlation and evaluates a representative view per
cluster.
\item {\bf  Bottom-up hierarchy traversal}: We observe that for a set of
  dimension attribute with a hierarchial structure, $H_{C_{i\ldots k}}$, if a
  view $V$ at hierarchy level $h$ has utility $u$, then views at hierarchy level
  $h-1$ will have utility $\leq$ $u$.
\item {\bf  Access frequency-based pruning}: In tables with a large number of
attributes, only a small subset of attributes are relevant to the analyst and
are therefore frequently accessed for data analysis. \SeeDB\ tracks access patterns
for each table to identify the most frequently accessed columns and combinations of
columns. While creating views, \SeeDB\ uses this information to prune attributes
that are rarely accessed and are thus likely to be unimportant.
\squishend

\vspace{5 mm}

%\subsubsection{View Query Optimizations}
%\label{subsubsec:optimizations}
\stitle{View Query Optimizations:}
The second set of optimizations used by \SeeDB\ minimizes the execution time for
view queries that haven't been pruned using the techniques described above.
Since view queries tend to be very similar in structure (they differ in the aggregation
attribute, grouping attribute or subset of data queried), \SeeDB\ uses multiple
techniques to intelligently combine view queries.
The ultimate goal is to minimize scans of the underlying dataset by sharing as
many table scans as possible. Our strategies include:

\vspace{5 mm}

\squishlist
  \item {\bf  Combine target and comparison view query}: Since the target view
  and comparison views only differ in the subset of data that the query is
  executed on, we can easily rewrite these two view queries as one.
  This simple optimization halves the time required to compute the results for
  a single view. 
  \item {\bf  Combine Multiple Aggregates}: A large number of view
  queries have the same group-by attribute but different aggregation attributes.
  Therefore, \SeeDB\ combines all view queries with the same group-by attribute
  into a single query. This rewriting provides a speed up linear in the
  number of aggregate attributes.
  \item {\bf  Combine Multiple Group-bys}: 
  Since \SeeDB\ computes a large number of group-bys, one significant
  optimization is to combine queries with different
  group-by attributes into a single query with multiple group-bys attributes.
  For instance, instead of executing queries for views $(a_1$, $m_1$, $f_1)$,
  $(a_2$, $m_1$, $f_1)$ \ldots $(a_n$, $m_1$, $f_1)$ independently, 
  we can combine the $n$ views into a single view represented by
  $(\{a_1, a_2\ldots a_n\}$, $m_1$, $f_1)$ and post-process results at the
  backend. Alternatively, if the SQL GROUPING SETS functionality is available in
  the underlying DBMS, \SeeDB\ can leverage that as well. 
  While this optimization has the potential to significantly reduce query
  execution time, the number of views that can be combined depends
  on the correlation between values of grouping attributes and system parameters like the
  working memory. Given a set of candidate views, we model the
  problem of finding the optimal combinations of views as a variant of
  bin-packing and apply ILP techniques to obtain the best solution. \\
%   (We discuss our model and
%   algorithm in our full paper~\ref{}).\agp{if full paper is not available
%   by the time of the demo, we can't cite it unfortunately..}
%   A variation of this approach also implemented
%   on \SeeDB\ is to send the results of the multiple group-by query to the front
%   end and ask the \SeeDB\ frontend to compute utility and select views. The
%   advantage of this approach is that it allows for more efficient interactive
%   exploration of the views.
  \item {\bf  Sampling}: For datasets of large size, an optimization that
  affects performance significantly is employing sampling: we  
  construct a sample of the dataset
  that can fit in memory and run all view queries against the sample. However, as
  expected, the sampling technique and size of the sample both affect
  view accuracy. 
  \item {\bf  Parallel Query Execution}: The final optimization that
  \SeeDB\ employs is taking advantage of parallel query execution 
  at the DBMS to reduce total latency.
  We observe that as the number of queries executed in parallel
  increases, the total latency decreases at the cost of
  increased per query execution time.
\squishend

\vspace{5 mm}

%If a dimension attribute $\mathcal{d}$ is highly correlated with measure
  %attribute $\mathcal{m}$, then?

It is possible to collect the above statistics at the dataset level too, as
opposed to the entire table level. The advantage of table level statistics is
that they have to be computed only once per table; however, dataset-level
statistics are more accurate since they only consider the specific parts of the
table. 
